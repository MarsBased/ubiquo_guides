h2. Ubiquo Core

This plugin contains the basic common Ubiquo structure so that other
plugins can be built on top of it. This includes:

* Ubiquo::Config system
* Core helpers
* Ubiquo layout and styling elements
* Main ruby/rails extensions
* Navigation links and tabs system
* Ubiquo filtered search

endprologue.

h3. Using configuration

Ubiquo::Config offers a place where store configuration variables

A value can have 2 states, added as default value and added as normal
value. If both setted, normal value is used.

It allow to store values in contexts using _context_ method.

NOTE: It's not recommended to change the value of the configuration during the life of the application, only in the setup

h4. Getting a value

To get a stored value of the configuration.

<ruby>
value = Ubiquo::Config.get(:key)
contexted_value = Ubiquo::Config.context(:context).get(:key)
</ruby>

h4. Creating a new value

You can create new values for the configuration.

<ruby>
Ubiquo::Config.add(:key, 'default_value')
Ubiquo::Config.context(:context).add(:key, default_value)
</ruby>

h4. Setting a normal value

when a key is added you can override their default value with _set_
method:

<ruby>
Ubiquo::Config.set(:key, 'normal_value')
Ubiquo::Config.context(:context).set(:key, normal_value)
</ruby>

h4. Inherited values

It is usefull for adding keys that their value is the same of another
key until it's not setted manually.

Currently is used to the plugins lists max row number, default to 10
but can be re-setted for a single list.

<ruby>
Ubiquo::Config.add_inheritance(:key, :existent_key)
Ubiquo::Config.context(:context).add_inheritance(:key, :existent_key)
</ruby>

h4. Use of config caller

Config caller let you to define keys with a lambda as value and
evaluate it in any context.

It's very powerfull to add hooks in the application.

Currently is used to all access_control calls of the plugins, letting
you to change it in your application without changing plugin code.

<ruby>
ubiquo_config_call(:key)
ubiquo_config_call(:key, {:context => :context})
</ruby>

h3. Core helpers

Ubiquo provides a series of helpers that can be useful in most ubiquo projects.
On the "rdoc":http://www.ubiquo.me/rdoc/ubiquo_core/classes/Ubiquo/Helpers.html
you will find an exhaustive list, and here examples for some of the most usual
plugins will be shown.

h4. Show helpers

The helpers in this group will assist you when creating 'show' pages in Ubiquo.

h5. Lists

<ruby>
ubiquo_show_list('Title', ['array', 'of', 'elements'])
</ruby>

This will create a normal, styled ul list.

h5. media_attachment helpers

Visit the "ubiquo_media":ubiquo_media.html guide if you are interested in helpers to
easily print lists of images or documents


h5. HTML text

Just add the class 'text' to the dd tag and you are ready


h3. Navigation

h4. Tabs navigations

All ubiquo applications have two tab navitations, one for normal mode
and one for superadmin mode. This tab navigator is what is showed
under the ubiquo header.

h5. Create new tab to the normal mode

Open RAILS_ROOT/app/views/navigators/_main_navtabs.html.erb.

Here you can edit navigator_left or navigator_right. Inside the
'create_tab_navigator' method block you can add new tabs with a piece
of code like that:

<ruby>
navigator.add_tab do |tab|
  tab.text = 'Your tab text'
  tab.title = 'Go to ...'
  tab.link = ubiquo_your_controllers_path
  tab.highlights_on({:controller => "ubiquo/your_controller"})
  tab.highlighted_class = "active"
end
</ruby>

h4. Link navigations

Link navigations work like tab navigations but showing links instead
tabs.

Currently there are only one default link navigation, but scaffold
generates one for the new controller.

The default navigation is showed on top of the Ubiquo, where is showed
user name, logout link, etc.

To add a link to any link navigation just add this code to the
'create_link_navigation' method block:

<ruby>
navigator.add_link do |link|
  link.text = 'Your link text'
  link.url = ubiquo_your_controllers_path
  link.highlights_on({:controller => "ubiquo/your_controller"})
end
</ruby>

h3. Filtered Search

Provides a mechanism to search and filter data in a model based on the params hash and named_scopes.

First step is to add the funcionality to the model:

<ruby>
class Article < ActiveRecord::Base
  filtered_search_scopes
end
</ruby>

This macro does several things:

* Adds some named scopes if some fields exist.
* Provides a filtered_search class method to search the model.
* Provides a paginated_filtered_search (same but suports a page parameter for pagination).

Let's check how it is normally used in the controller:

<ruby>
def index
  @articles_pages, @articles = Article.paginated_filtered_search(params)

  respond_to do |format|
    format.html # index.html.erb
    format.xml  {
      render :xml => @articles
    }
  end
end
</ruby>

What this does is match the "filter_blah" like params to "blah" scopes, it also takes into account order_by and sort_order params.

h4. Default named_scopes

Some named_scopes are automatically created if some fields exist in the table. For example:

If title, name or description exist a "text" named_scope will be created. This named scope suports case and accent insensitive search.

<ruby>
named_scope :text, lambda { |value|
  match = accent_insensitive_regexp(value.downcase)
  matches = fields.inject([]) { |r, f| r << match }
  conditions = fields.map { |f| "lower(#{table_name}.#{f}) #{regexp_op} ?" }.join(" OR ")
  { :conditions => [ conditions, *matches ] }
}
</ruby>

So a param called filter_text would match against this scope and its value passed to it.

If a published_at field exist two named_scopes will be created:

<ruby>
named_scope :publish_start , lambda { |value| { :conditions => ["#{table_name}.published_at >= ?", parse_date(value)] } }
named_scope :publish_end   , lambda { |value| { :conditions => ["#{table_name}.published_at <= ?", parse_date(value, :time_offset => 1.day)] } }
</ruby>

h4. Enabling named_scopes and customizing text search

Default scopes are enabled by default by just including the filtered_search_scopes macro in the model.

You can disable them:

<ruby>
class Article < ActiveRecord::Base
  filtered_search_scopes :defaults => false
end
</ruby>

If you need to enable some additional scopes you can do so:

<ruby>
class Article < ActiveRecord::Base
  filtered_search_scopes :enable => [ :myscope1, :myscope2, :myscope3 ]
end
</ruby>

Enabling scopes means that they would be elegible to be matched against filter_ like params.

Additionally you can customize which fields do you want the text named_scope to operate on:

<ruby>
class Article < ActiveRecord::Base
  filtered_search_scopes :text => [ :myfield1, :myfield2, :myfield3 ]
end
</ruby>

h4. Using filtered_search

You can search and filter results using 2 methods:

* filtered_search
* paginated_filtered_search

Usually you will pass the params hash to the paginated_filtered_search methods as seen in previous examples but you can also pass additional conditions to the search too.

<ruby>
@articles_pages, @articles = Article.paginated_filtered_search(params, :include => :books)
</ruby>

Valid params for filters and options are:

* filter_ like params (to match against named scopes).
* sort_order and order_by for ordering.
* page and per_page params for pagination. (if using paginated_filter_search).

h3. Changelog

"Lighthouse tickets":http://ubiquo.lighthouseapp.com/projects/27683-ubiquo/tickets?q=tagged%3Aubiquo_core
