h2. Ubiquo Core

This plugin contains the basic common Ubiquo structure so that other
plugins can be built on top of it. This includes:

* Ubiquo::Config system
* Core helpers
* Ubiquo layout and styling elements
* Main ruby/rails extensions
* Navigation links and tabs system
* Ubiquo filtered search
* Relation selector

endprologue.

h3. Using configuration

Ubiquo::Config offers a place where store configuration variables

A value can have 2 states, added as default value and added as normal
value. If both setted, normal value is used.

It allow to store values in contexts using _context_ method.

NOTE: It's not recommended to change the value of the configuration during the life of the application, only in the setup

h4. Getting a value

To get a stored value of the configuration.

<ruby>
value = Ubiquo::Config.get(:key)
contexted_value = Ubiquo::Config.context(:context).get(:key)
</ruby>

h4. Creating a new value

You can create new values for the configuration.

<ruby>
Ubiquo::Config.add(:key, 'default_value')
Ubiquo::Config.context(:context).add(:key, default_value)
</ruby>

h4. Setting a normal value

when a key is added you can override their default value with _set_
method:

<ruby>
Ubiquo::Config.set(:key, 'normal_value')
Ubiquo::Config.context(:context).set(:key, normal_value)
</ruby>

h4. Inherited values

It is usefull for adding keys that their value is the same of another
key until it's not setted manually.

Currently is used to the plugins lists max row number, default to 10
but can be re-setted for a single list.

<ruby>
Ubiquo::Config.add_inheritance(:key, :existent_key)
Ubiquo::Config.context(:context).add_inheritance(:key, :existent_key)
</ruby>

h4. Use of config caller

Config caller let you to define keys with a lambda as value and
evaluate it in any context.

It's very powerfull to add hooks in the application.

Currently is used to all access_control calls of the plugins, letting
you to change it in your application without changing plugin code.

<ruby>
ubiquo_config_call(:key)
ubiquo_config_call(:key, {:context => :context})
</ruby>

h3. Core helpers

Ubiquo provides a series of helpers that can be useful in most ubiquo projects.
On the "rdoc":http://www.ubiquo.me/rdoc/ubiquo_core/classes/Ubiquo/Helpers.html
you will find an exhaustive list, and here examples for some of the most usual
plugins will be shown.

h4. Show helpers

The helpers in this group will assist you when creating 'show' pages in Ubiquo.

h5. Lists

<ruby>
ubiquo_show_list('Title', ['array', 'of', 'elements'])
</ruby>

This will create a normal, styled ul list.

h5. media_attachment helpers

Visit the "ubiquo_media":ubiquo_media.html guide if you are interested in helpers to
easily print lists of images or documents


h5. HTML text

Just add the class 'text' to the dd tag and you are ready


h3. Navigation

h4. Tabs navigations

All ubiquo applications have two tab navitations, one for normal mode
and one for superadmin mode. This tab navigator is what is showed
under the ubiquo header.

h5. Create new tab to the normal mode

Open RAILS_ROOT/app/views/navigators/_main_navtabs.html.erb.

Here you can edit navigator_left or navigator_right. Inside the
'create_tab_navigator' method block you can add new tabs with a piece
of code like that:

<ruby>
navigator.add_tab do |tab|
  tab.text = 'Your tab text'
  tab.title = 'Go to ...'
  tab.link = ubiquo_your_controllers_path
  tab.highlights_on({:controller => "ubiquo/your_controller"})
  tab.highlighted_class = "active"
end
</ruby>

h4. Link navigations

Link navigations work like tab navigations but showing links instead
tabs.

Currently there are only one default link navigation, but scaffold
generates one for the new controller.

The default navigation is showed on top of the Ubiquo, where is showed
user name, logout link, etc.

To add a link to any link navigation just add this code to the
'create_link_navigation' method block:

<ruby>
navigator.add_link do |link|
  link.text = 'Your link text'
  link.url = ubiquo_your_controllers_path
  link.highlights_on({:controller => "ubiquo/your_controller"})
end
</ruby>

h3. Filtered Search

Provides a mechanism to search and filter data in a model based on the params hash and named_scopes.

First step is to add the funcionality to the model:

<ruby>
class Article < ActiveRecord::Base
  filtered_search_scopes
end
</ruby>

This macro does several things:

* Adds some named scopes if some fields exist.
* Provides a filtered_search class method to search the model.
* Provides a paginated_filtered_search (same but suports a page parameter for pagination).

Let's check how it is normally used in the controller:

<ruby>
def index
  @articles_pages, @articles = Article.paginated_filtered_search(params)

  respond_to do |format|
    format.html # index.html.erb
    format.xml  {
      render :xml => @articles
    }
  end
end
</ruby>

What this does is match the "filter_blah" like params to "blah" scopes, it also takes into account order_by and sort_order params.

h4. Default named_scopes

Some named_scopes are automatically created if some fields exist in the table. For example:

If title, name or description exist a "text" named_scope will be created. This named scope suports case and accent insensitive search.

<ruby>
named_scope :text, lambda { |value|
  match = accent_insensitive_regexp(value.downcase)
  matches = fields.inject([]) { |r, f| r << match }
  conditions = fields.map { |f| "lower(#{table_name}.#{f}) #{regexp_op} ?" }.join(" OR ")
  { :conditions => [ conditions, *matches ] }
}
</ruby>

So a param called filter_text would match against this scope and its value passed to it.

If a published_at field exist two named_scopes will be created:

<ruby>
named_scope :publish_start , lambda { |value| { :conditions => ["#{table_name}.published_at >= ?", parse_date(value)] } }
named_scope :publish_end   , lambda { |value| { :conditions => ["#{table_name}.published_at <= ?", parse_date(value, :time_offset => 1.day)] } }
</ruby>

h4. Enabling named_scopes and customizing text search

Default scopes are enabled by default by just including the filtered_search_scopes macro in the model.

You can disable them:

<ruby>
class Article < ActiveRecord::Base
  filtered_search_scopes :defaults => false
end
</ruby>

If you need to enable some additional scopes you can do so:

<ruby>
class Article < ActiveRecord::Base
  filtered_search_scopes :enable => [ :myscope1, :myscope2, :myscope3 ]
end
</ruby>

Enabling scopes means that they would be elegible to be matched against filter_ like params.

Additionally you can customize which fields do you want the text named_scope to operate on:

<ruby>
class Article < ActiveRecord::Base
  filtered_search_scopes :text => [ :myfield1, :myfield2, :myfield3 ]
end
</ruby>

h4. Using filtered_search

You can search and filter results using 2 methods:

* filtered_search
* paginated_filtered_search

Usually you will pass the params hash to the paginated_filtered_search methods as seen in previous examples but you can also pass additional conditions to the search too.

<ruby>
@articles_pages, @articles = Article.paginated_filtered_search(params, :include => :books)
</ruby>

Valid params for filters and options are:

* filter_ like params (to match against named scopes).
* sort_order and order_by for ordering.
* page and per_page params for pagination. (if using paginated_filter_search).

h3. Relation selector

Ubiquo relation selector provides an easy way to implement form-controls on model to model relations. This feature offers a compact view to work with different relation types, like belongs_to and has_many through different controls.

Supported relations are belongs_to, has_many and has_many through with all their options

<ruby>
Model:
belongs_to :author

View:
<%= form.relation_selector :authors %>
</ruby>

h4. Selector types

Current selector types are:
* **Select**: select form, used to manage belongs_to relations, displaying all available options in a list with the instance choice as a selected one.
	Example: form.relation_selector :publisher, :type => :select
* **Check box group**: a group of checkboxes, used to manage has_many relations, displaying all available options and marking the instances choices.
	Example: form.relation_selector :authors, :type => :checkbox
* **Text field with autocomplete functionality**: a text field with autocomplete functionality, used to manage both belongs_to and has_many relations, offering a list of available options filtered for the current text entered by user. It blocks input depending on the size of the given relation.
	Example: form.relation_selector :authors, :type => :autocomplete

h4. Common options allowed

Options allowed for this helper are:
* **type(optional, default => autocomplete)**: to choose the type of selector. Options available are select, check_box and autocomplete
* **autocomplete_style(optional)**: this option will allow to choose between text-field like autocomplete or list-field like autocomplete.
* **name_field(optional, default => [title, name])**: to choose which model field will be displayed to the final user. This field must be a valid model field or a valid function with a string type return. 
* **collection_url(optional)**: this option will give the needed string to be called to retrieve model instances from its controller. The string must be a valid rails url generator.
* **url_params(optional)**: this option will contain all additional params needed for all requests made by relation selector to retrieve desired objects.
* **required(optional)**: this option will append a * character to the given control, showing if that data field is required.
* **add_callback(optional)**: this option allows user to register a callback function that will be triggered when adding occur.
* **remove_callback(optional)**:  this option allows user to register a callback function that will be triggered when removing occur
* **related_object_id_field(optional, default => id)**: this field will be used as the given class objects identifier.

h4. Required code

The code required to use this helper is the following:
* **Related models for autocomplete**: if use of autocomplete selector type is required, the related model will need to add a json return format to its index controller action (default url discovery option) or another arbitrary defined action with the same return requirements (collection_url option)

h4. General examples

h5. Autocomplete with custom name field and collection_url

<ruby>
form.relation_selector :authors, 
		       :type => :autocomplete, 
		       :name_field => 'custom_name', 
		       :collection_url => 'custom_element_retriever_url'	
</ruby>

h5. Checkbox group with select/unselect callbacks

<ruby>
form.relation_selector :authors, 
		       :type => :checkbox,
		       :add_callback => 'custom_add_callback',
		       :remove_callback => 'custom_remove_callback'
	...
	(javascript code)
	function custom_add_callback(){
		...
	}
	function custom_remove_callback(){
		...
	}
	(/javascript code)

</ruby>

h5. Autocomplete with filters

<ruby>
form.relation_selector :authors, 
		       :type => :autocomplete,
		       :url_params => {:filter_first_field => 'custom_value_1',
		   		       :filter_second_field => 'custom_value_2'}

</ruby>

h4. Notes

The required javascript to make it work is included by default at new projects to the main ubiquo layout. However, if you're adding this new feature to an older project, you must include that javascript.

Then, file app/views/layouts/ubiquo/default.html.erb will have a javascript_include_tag as follows

* javascript_include_tag **'ubiquo/relation_selector.js'**

With the bolded part being the needed new inclusion


h3. Changelog

"Lighthouse tickets":http://ubiquo.lighthouseapp.com/projects/27683-ubiquo/tickets?q=tagged%3Aubiquo_core
