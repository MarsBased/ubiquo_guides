h2. Ubiquo i18n

The ubiquo_i18n plugin provides an easy yet powerful way to resolve the common issue that i18n represents to an application.

This plugin is not about the ubiquo interface, which also comes with out of the box i18n capabilites (using the "Rails i18n system":http://guides.rubyonrails.org/i18n.html). This is about translating data from models.

It tries to be simple to use, but also is filled with a lot of useful features, among which:

* Define which attributes in a model are translatable with a single line.
* Every translation is a separate instance, so you can operate on it transparently, as you did before ubiquo_i18n
* Automatic update of shared attributes among translations
* Define relations that should be shared between translations, ubiquo_i18n will track them for you
* Use instance.translate('locale') to create a translation of an existing model instance

This guide will walk you through ubiquo_i18n internals and show you how to create a ubiquo_i18n-ized model.

endprologue.


h3. Creating translatable models

In this example we will create an Article model, which will have some translatable attributes and relations.

h4. Scaffolding

If you are going to start a fresh new model, the easiest and quickiest way to create a translatable model is using the ubiquo_model scaffold

<shell>
$ script/generate ubiquo_model Article title:string description:string --translatable title,description
</shell>

NOTE: If the above is new for you, see the "Ubiquo Scaffold guide":ubiquo_scaffold.html

This will make the necessary changes in the model and migration to create an Article model with translatable title and description. You could also have used ubiquo_scaffold, if you need a full scaffold, and the created controller and views would have been also filled with the particular i18n goodies.


h4. Manual creation

If you don't want to use scaffolding, e.g. because the model file that you want to make translatable already exists, these are the changes that you'll need to do:

h5. Migrations

This is how the migration to create a table of a translated model looks like:

<ruby>
    create_table :articles, :translatable => true do |t|
      t.string :title
      t.string :description
      ...
    end
</ruby>

As you can see, the only special thing here is that a translatable option is added, and will result in adding a locale and content_id fields to the articles table. The rest of the attributes are created as usual.

NOTE: The content_id field is implemented as a sequence field, not simply an integer.

h5. Models

On models, we can indicate which fields can be translated by using:

<ruby>
class Article < ActiveRecord::Base

  translatable :title, :description
</ruby>

The created model file has the title and descriptions fields defined as translatable, but since we actually have one full table row per instance, which attributes are shared and which ones are translatable can be defined dynamicly without affecting the db, so this list can be changed from the model at any moment without creating a new migration.

h4. Using translatable models

So now that we have the Article model, it's time to use it.

<ruby>
Article.create(:title => 'title', :description => 'desc', :locale => 'en')
</ruby>

This is an old school create, that just have an extra argument, the locale this article is written in. This call will fill the content_id field with a new, unique value, since this is a new Article, not a translation of an existing one. If the latter is what we are looking for, we would use:

<ruby>
Article.first.translate('ca')
</ruby>

This will return a new, unsaved article which shares the same content_id with Article.first. But the content_id is not the only thing that is shared, because all the fields that are not defined as translatable in the model, will also be filled with the common value.

If you now do the following:

<ruby>
Article.first.update_attribute(:title => 'new_title')
</ruby>

It will work as expected, just updating the title in Article.first. Had :title been not defined as a translatable attribute, 'new_title' would have been set as the title in all the Article instances sharing the same content_id.


h4. locale() method

The locale() method is one of the most useful and powerful in ubiquo_i18n. You can think of it as a named scope that accepts a list of locales, and will return the instances matching the given locales taking the order as the preference. This is easily seen with examples:

<ruby>
Article.locale('en')
# returns all articles in English

Article.locale('en', 'ca').count
# returns the count of all the articles that have an English and/or a Catalan version

Article.locale('en', :ALL)
# returns all the articles in English if they have an English version, otherwise in any language

Article.first.in_locale('en', 'es', 'ca')
# If an article is in English it is returned, if not, the Spanish version is added, and if neither 'en' nor 'es' locale is present for each different content_id, the Catalan is used. If even this is not found, that content_id will not have any language version returned.
</ruby>

NOTE: The in_locale() method is the equivalent to the locale() method to be used if we start a locale search from an instance.

h3. Changelog

"Lighthouse tickets":http://ubiquo.lighthouseapp.com/projects/27683-ubiquo/tickets?q=tagged%3Aubiquo_i18n
